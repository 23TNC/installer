package mirror

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/openshift/installer/pkg/asset"
	"github.com/pelletier/go-toml"
	"github.com/pkg/errors"
)

var (
	// RegistriesConfFilename defines the name of the file on disk
	RegistriesConfFilename = filepath.Join(mirrorConfigDir, "registries.conf")
)

// RegistriesConf generates the registries.conf file.
type RegistriesConf struct {
	File         *asset.File
	MirrorConfig []RegistriesConfig
}

// RegistriesConfig holds the data extracted from registries.conf
type RegistriesConfig struct {
	Location string
	Mirror   string
}

var _ asset.WritableAsset = (*RegistriesConf)(nil)

// Name returns a human friendly name for the asset.
func (*RegistriesConf) Name() string {
	return "Mirror Registries Config"
}

// Dependencies returns all of the dependencies directly needed to generate
// the asset.
func (*RegistriesConf) Dependencies() []asset.Asset {
	return []asset.Asset{
		// &installconfig.InstallConfig{},
	}
}

// Generate generates the registries.conf file from install-config.
func (i *RegistriesConf) Generate(dependencies asset.Parents) error {

	// installConfig := &installconfig.InstallConfig{}

	// registries := []sysregistriesv2.Registry{}
	// for _, group := range bootstrap.MergedMirrorSets(installConfig.Config.ImageContentSources) {
	//        if len(group.Mirrors) == 0 {
	//                continue
	//        }

	//        registry := sysregistriesv2.Registry{}
	//        registry.Endpoint.Location = group.Source
	//        registry.MirrorByDigestOnly = true
	//        for _, mirror := range group.Mirrors {
	//                registry.Mirrors = append(registry.Mirrors, sysregistriesv2.Endpoint{Location: mirror})
	//        }
	//        registries = append(registries, registry)
	// }

	// i.File = &asset.File{
	//      Filename: RegistriesConfFilename,
	//      Data:     registries,
	// }

	// return i.finish()

	return nil
}

// Files returns the files generated by the asset.
func (i *RegistriesConf) Files() []*asset.File {
	if i.File != nil {
		return []*asset.File{i.File}
	}
	return []*asset.File{}
}

// Load returns RegistriesConf asset from the disk.
func (i *RegistriesConf) Load(f asset.FileFetcher) (bool, error) {

	file, err := f.FetchByName(RegistriesConfFilename)
	if err != nil {
		if os.IsNotExist(err) {
			return false, nil
		}
		return false, errors.Wrap(err, fmt.Sprintf("failed to load %s file", RegistriesConfFilename))
	}

	i.File = file

	if err = i.finish(); err != nil {
		return false, err
	}

	return true, nil
}

func (i *RegistriesConf) finish() error {

	config, err := extractLocationMirrorDataFromRegistries(string(i.File.Data))
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("failed to parse mirrors in %s", RegistriesConfFilename))
	}

	i.MirrorConfig = config

	return nil
}

// From assisted-service pkg/mirrorregistries/generator.go
func extractLocationMirrorDataFromRegistries(registriesConfToml string) ([]RegistriesConfig, error) {
	tomlTree, err := toml.Load(registriesConfToml)
	if err != nil {
		return nil, err
	}

	registriesTree, ok := tomlTree.Get("registry").([]*toml.Tree)
	if !ok {
		return nil, fmt.Errorf("failed to cast registry key to toml Tree")
	}
	registriesConfList := make([]RegistriesConfig, len(registriesTree))
	for i, registryTree := range registriesTree {
		location, ok := registryTree.Get("location").(string)
		if !ok {
			return nil, fmt.Errorf("failed to cast location key to string")
		}
		mirrorTree, ok := registryTree.Get("mirror").([]*toml.Tree)
		if !ok {
			return nil, fmt.Errorf("failed to cast mirror key to toml Tree")
		}
		mirror, ok := mirrorTree[0].Get("location").(string)
		if !ok {
			return nil, fmt.Errorf("failed to cast mirror location key to string")
		}
		registriesConfList[i] = RegistriesConfig{Location: location, Mirror: mirror}
	}

	return registriesConfList, nil
}
